# Tasks for Copilot

This file contains tasks for GitHub Copilot to complete. Add your tasks below and I'll work through them.
Defining the rozmoWA Niche: The "Structured Fun" Philosophy
rozmoWA will occupy a unique position in the market by implementing a hybrid "Structured Fun" philosophy. This model synthesizes the motivational mechanics of gamification, as seen in Duolingo, with the rigorous, conversation-centric curriculum of platforms like Babbel. The objective is to create a cohesive learning journey that guides users from foundational knowledge to confident, real-world communication, without sacrificing engagement.
The application will adopt a structured progression aligned with established frameworks like the Common European Framework of Reference for Languages (CEFR), ensuring that learning is logical and measurable.5 This structure will house all content‚Äîclasses, lessons, and exams‚Äîin a coherent path. However, this content will be delivered within a gamified framework featuring points, streaks, achievements, and leaderboards, making the rigorous process of learning feel rewarding and enjoyable.3 This approach directly addresses the need for a comprehensive platform that is both educationally sound and persistently motivating.
1.3 Core Pedagogical Pillars

The "Structured Fun" philosophy is supported by three core pedagogical pillars that leverage modern technological trends to maximize learning outcomes.

1.3.1 AI-Powered Personalization

Artificial intelligence is the engine that makes the rozmoWA model viable. Instead of a static, one-size-fits-all curriculum, the platform will feature an adaptive learning system.16 By analyzing user performance data from quizzes, exercises, and interactions, the system will identify individual strengths and weaknesses.14 This allows the platform to dynamically adjust the difficulty, content, and focus of subsequent lessons. For example, if a user consistently struggles with the present perfect tense, the system will automatically surface more lessons and review activities targeting that specific grammar point. This ensures learners are always operating at their optimal level of challenge, a state conducive to effective learning, which prevents the disengagement caused by content that is either too easy or too frustratingly difficult.16 Gamification is then tied directly to mastering these personalized challenges, transforming it from a superficial layer into a meaningful framework for targeted improvement.

1.3.2 Active Production over Passive Recognition

A significant limitation of many popular language apps is their over-reliance on passive recognition tasks, such as multiple-choice questions, which do not adequately prepare learners for spontaneous speech and writing.5 rozmoWA will prioritize "output" and active production of language. This will be implemented through several key features:
Speech Recognition: Integrated speech recognition tools will provide instant feedback on pronunciation and intonation, allowing users to practice speaking and compare their attempts to native speaker audio.9
Constructed Response Questions: Quizzes and exercises will frequently require users to type full sentences or fill in blanks, moving beyond simple word matching.5
Scenario-Based Tasks: Lessons will culminate in practical, scenario-based questions where users must apply their knowledge to solve a real-world communication problem, such as ordering food or asking for directions.14

1.3.3 Contextual and Immersive Learning

Language is best learned in context, not as a list of isolated vocabulary words and grammar rules. All learning materials within rozmoWA will be authentic and centered around real-world themes and situations.14 This principle will be enhanced by two key features:
Interactive Media: Lessons will integrate interactive video and audio, where users can click on words for definitions, answer comprehension questions that appear during playback, and engage with content in a more dynamic way.5
User-Generated Content: The platform's architecture will support the upload and integration of the instructor's own materials‚Äîarticles, videos, audio clips‚Äîinto the learning path. This allows for a highly customized and relevant curriculum, a feature that provides a significant advantage over the closed content ecosystems of many competitors.5 This directly fulfills the user's requirement for a platform that can house everything they upload.
The platform is conceived not merely as a content delivery app but as an "All-in-One Learning Ecosystem".14 This integrated approach means that from the moment a user logs in, their dashboard provides a holistic view of their entire learning journey‚Äîupcoming lessons, pending reviews, exam schedules, and accessible resources. This structure is fundamental to the application's design, ensuring a seamless and comprehensive user experience.
Section 2: The rozmoWA Visual Identity and Design System

This section translates the strategic goals into a concrete visual language. A comprehensive design system is essential for creating an application that is modern, smart, and visually satisfying, while also ensuring accessibility, scalability, and a consistent user experience. This system will serve as the foundational rulebook for the application's front-end development.

2.1 Core Design Philosophy: "Clarity and Calm"

The foremost UI/UX trend for educational applications in 2025 is a minimalist, simplified, and clutter-free interface.16 This design philosophy is not merely aesthetic; it is functional. By reducing visual noise and prioritizing essential content, a minimalist design lowers the user's cognitive load, allowing their mental energy to be focused entirely on the learning material.8
rozmoWA will embody a "Clarity and Calm" philosophy. The design will make extensive use of whitespace, employ a clear and legible typographic hierarchy, and feature intuitive, consistent navigation patterns.16 The overall feel will be professional, supportive, and serene, creating an optimal environment for focused study. This approach directly supports the learning process by removing distractions and making the interface feel effortless to use.

2.2 Color Palette: Earthy, Grounded, with Energetic Accents

The color palette is selected based on 2025 design trends that favor palettes evoking stability, calm, and focused energy.23
Primary Palette: The foundational colors for backgrounds, containers, and main interface elements will be drawn from earthy, neutral tones. A color like "Mocha Mousse" (a rich, earthy brown) or similar soft, opulent neutrals provides a sense of calm, authenticity, and sophistication.23 These grounded tones create a comfortable and non-distracting backdrop for learning.
Accent Palette: To guide the user's attention and inject energy, a vibrant accent color will be used for primary calls-to-action (CTAs), progress indicators, interactive element states, and notifications. A "Burning Red" or a "Sunny Yellow" provides high contrast and creates a clear visual cue for important actions, fostering motivation and clarity.23
Semantic Palette: A dedicated set of colors will be used to convey specific meanings consistently throughout the app:
Success: A soft, reassuring green for correct answers and positive feedback.
Error/Warning: The primary accent red will be used for error messages and critical alerts.
Information: A serene, trustworthy blue (from the "Sea to Sky" trend) for informational tooltips and non-critical notifications.23
Dark Mode: A dark mode theme is a mandatory feature, aligning with modern user expectations and accessibility best practices. It reduces eye strain in low-light conditions and can conserve battery life on OLED screens.16 The entire color system will be designed with corresponding dark mode values from the outset to ensure a seamless and high-quality experience in both themes.

2.3 Typography: Legibility and Modernity

Typography is paramount for readability and establishing a professional, trustworthy tone. The font choices prioritize on-screen legibility and modern aesthetics.26
UI & Body Font: Inter will be used for all body copy and general interface text. Inter is a variable sans-serif typeface designed specifically for UI design, offering exceptional clarity and readability across various sizes and screen resolutions.26 Its clean, neutral geometry ensures that the focus remains on the content.
Heading Font: Poppins, a geometric sans-serif with rounded curves, will be used for major headings (H1, H2). It provides a modern, friendly, and slightly playful character that complements the "Structured Fun" philosophy without sacrificing professionalism.26
Hierarchy: A strict and consistent typographic scale will be established to create a clear visual hierarchy. This ensures that users can intuitively understand the structure and importance of information on any given page.

2.4 Iconography: Simple, Clean, and Universal

Icons serve as a universal language for navigation and action. The 2025 trend is a move towards minimalist, clean, and functionally clear icons that are easily recognizable.29
Style: A single, consistent icon library, such as Lucide Icons, will be used throughout the application. The style will be a clean, consistent line-icon format. This avoids the visual clutter of multiple styles and the dated look of skeuomorphic or overly detailed icons.29
Functionality: Icons will be used purposefully to guide users and represent actions, not as mere decoration. In primary navigation and for any potentially ambiguous actions, icons will be paired with clear text labels to maximize clarity and accessibility.30
Beyond static elements, the design will incorporate principles of "Emotion-Driven Design".16 This involves using subtle micro-interactions and animations to make the application feel more responsive and alive.22 For instance, a correct answer might trigger a brief, satisfying animation; a completed lesson could cause the progress bar to fill smoothly; and buttons will have subtle feedback on click. These details enhance the user experience, transforming it from merely functional to delightful and motivating.
Category
Specification
Light Mode Value
Dark Mode Value
Colors
Primary Background
hsl(30, 25%, 95%)
hsl(240, 10%, 12%)


Container Background
hsl(0, 0%, 100%)
hsl(240, 6%, 16%)


Primary Text
hsl(240, 10%, 15%)
hsl(30, 25%, 95%)


Secondary Text
hsl(240, 5%, 45%)
hsl(240, 5%, 65%)


Accent (CTA, Active)
hsl(350, 85%, 55%)
hsl(350, 90%, 65%)


Success
hsl(140, 70%, 40%)
hsl(140, 60%, 55%)


Information
hsl(210, 80%, 50%)
hsl(210, 85%, 65%)


Borders
hsl(240, 10%, 85%)
hsl(240, 5%, 25%)
Typography
Heading Font
Poppins
Poppins


Body/UI Font
Inter
Inter


H1
36px, Bold (700)




H2
28px, Semi-Bold (600)




H3
22px, Semi-Bold (600)




Body
16px, Regular (400)




Small/Caption
14px, Regular (400)


Spacing
Base Unit
4px




xs
4px (1 unit)




sm
8px (2 units)




md
16px (4 units)




lg
24px (6 units)




xl
32px (8 units)


Iconography
Library
Lucide Icons




Style
Line, 1.5px stroke width




Section 3: Information Architecture and Core User Flows

A logical and intuitive information architecture (IA) is the backbone of a successful application. It defines the structure of the content and the paths users take to accomplish their goals. The IA for rozmoWA is designed to be simple, predictable, and scalable.

---

## üìã Task Queue

### Task 1: [Add your task title here]
Onboarding and Personalization Setup

The initial user experience is critical for retention. Following the successful onboarding pattern of platforms like Duolingo, rozmoWA will delay mandatory account creation until the user has experienced the core value proposition of the application.31 This approach leverages the psychological principle of reciprocity: by providing value upfront, users are more motivated to complete the sign-up process to save their progres

**Details:**
Welcome Screen: A clean screen with the app's value proposition and a single CTA to "Get Started."
Language Selection: User chooses English.
Goal & Proficiency Assessment: A short, friendly questionnaire (3-4 steps) to establish the user's learning goals (e.g., travel, business, exam preparation) and self-assessed proficiency level (e.g., "I'm new to English," "I know some basics"). This data is the initial input for the AI personalization engine.
Introductory Micro-Lesson: The user immediately engages in a short (2-3 minute) interactive lesson that showcases the platform's core mechanics (e.g., a vocabulary matching game, a simple sentence construction task).
Profile Creation Prompt: Upon completing the micro-lesson and earning their first points, a modal appears prompting the user to create a profile to save their progress and unlock their personalized learning path.

The Core Application Map

The application is organized into a few primary sections, accessible via a persistent navigation element. On desktop, this will be a collapsible sidebar; on mobile, it will be a bottom tab bar. This ensures key areas are always one click away.
Dashboard: The personalized home screen and central hub. It provides an at-a-glance overview of progress and suggests the next action.
Learn (Course Catalog): The primary destination for discovering and engaging with all learning content. This is designed not as a static list but as a dynamic "Learning Path Navigator." The UI will visually represent the user's journey, showing completed lessons, the current lesson, and AI-recommended next steps, making the path forward clear and motivating.33
Review: A dedicated area powered by a spaced repetition system (SRS). Vocabulary, phrases, and grammar concepts that the user has struggled with are automatically added to a review queue, ensuring long-term retention.2
Resources: A centralized digital library for all supplementary materials uploaded by the instructor (e.g., PDFs, videos, audio files, external links). This makes it easy for learners to find study aids associated with their courses.
Community (Future Scope): A placeholder for future expansion into social learning features, such as forums, leaderboards, or connecting with language partners, which are known to be highly effective for maintaining motivation.2
Profile: The user's personal space to view achievements, track detailed statistics, and manage account settings.

3.3 The Primary Learning Loop

The core user engagement cycle is designed to be a continuous, reinforcing loop that drives progress:
Discover: From the Dashboard or the Learn page, the user selects their next lesson, which has been recommended by the AI personalization engine.
Engage: The user proceeds through the interactive steps of the lesson (e.g., watching a video, reading a text, completing exercises).
Assess: The user's understanding is tested through an embedded quiz. Performance data is captured and analyzed by the system.
Reinforce: Any concepts or vocabulary where the user showed weakness are automatically flagged and added to their personalized queue in the "Review" section.
Track: The user's progress (XP earned, lesson completion, streak) is immediately updated and reflected on their Dashboard and Profile pages, providing instant positive feedback.
Repeat: The user is seamlessly guided to their next recommended lesson, continuing the cycle.
This architecture ensures that learning is not a random walk through content but a guided, personalized, and continuously reinforced journey toward fluency.

Section 4: Detailed Component and Page Blueprints

This section provides a granular breakdown of each key page and its constituent components. These blueprints serve as detailed technical specifications for development, ensuring that the final implementation aligns perfectly with the design vision.

4.1 The Personalized User Dashboard

The dashboard is the user's mission control. Its purpose is to provide an immediate, at-a-glance summary of their learning status and a clear, compelling call to their next action, adhering to the "five-second rule" where users can grasp the most important information instantly.35 The layout will be a responsive grid of cards, with information prioritized according to a Z-shaped scanning pattern.35
Key Components:
ContinueLearningCard: The most prominent element, located in the top-left. It displays the title of the user's current or next recommended lesson, a brief description, and a large, high-contrast "Start Lesson" CTA button. It will also feature a progress bar showing completion percentage for the current course module.38
DailyGoalsCard: A visual and motivating component showing the user's daily learning streak (e.g., a flame icon with the number of consecutive days) and a circular progress bar indicating their progress towards a daily XP (experience points) goal.4
ReviewQueueCard: A simple card that notifies the user of items due for review. It will display a number (e.g., "15 items to review") and a "Start Review" CTA, creating a low-friction path to this critical learning activity.
StatsOverviewCard: A row of smaller, secondary cards that display key lifetime metrics such as "Total Words Learned," "Lessons Completed," and "Highest Streak." These provide a sense of long-term accomplishment.35
AnnouncementsFeed: A compact, scrollable list for brief updates, such as the availability of a new course or a message from the instructor.

4.2 The Dynamic Course & Lesson Catalog ("Learn" Page)

This page is the gateway to all educational content. It must be designed for easy exploration and discovery, guiding users toward content that is relevant to their personalized learning path.33
Key Components:
SearchBar and FilterControls: Positioned prominently at the top of the page. The search bar will allow keyword searches. Filters will enable users to narrow the content by key criteria: Skill Level (Beginner, Intermediate, Advanced), Category (Grammar, Vocabulary, Conversation, Reading), and Content-Type (Course, Lesson, Exam).33
LearningPathView: The default view for this page. It will visually render the user's AI-generated learning path as a map or a vertical timeline, showing completed modules, the current module, and upcoming recommended modules. This transforms a simple catalog into a guided journey.
CourseCard: The fundamental building block of the catalog grid. Each card will be a self-contained preview of a course. It will include a compelling banner image, the course title, a one-sentence description, and tags for its level and category. A progress bar will be overlaid if the user has started the course. The entire card will be clickable to reduce interaction cost and improve usability.21

4.3 The Interactive Lesson & Media View

This is the core learning environment, designed to be focused and distraction-free to maximize comprehension and engagement.
Key Components:
LessonStepper: A persistent, collapsible sidebar that serves as a table of contents for the current lesson. It lists all components of the lesson (e.g., "1. Introduction Video," "2. Vocabulary Drill," "3. Reading Text," "4. Final Quiz") and visually indicates the user's progress, allowing them to navigate between sections easily.
VideoPlayer: A clean, modern video player for lesson content. It will support standard controls and captions for accessibility. The architecture should allow for future integration of interactive elements like in-video questions.16
RichTextViewer: A component for displaying formatted articles, transcripts, and lesson notes with clear, legible typography.
EmbeddedQuiz: A container for rendering interactive question components from the Quiz Engine (see 4.4).
NavigationButtons: Large, clear "Previous" and "Next" buttons at the bottom of the content area to guide the user sequentially through the lesson steps. The "Next" button will be disabled until the current step's task is completed.

4.4 The Adaptive Quiz & Examination Engine

The quiz engine is a critical tool for assessment and data collection for the AI system. The interface must be clear, intuitive, and stress-free.
Layout: A single-question-at-a-time layout is essential. This approach automatically saves the user's answer after each question, preventing data loss from network interruptions, and reduces cognitive load by allowing the user to focus on one problem at a time.40 A progress bar at the top will clearly indicate the user's position in the quiz (e.g., "Question 3 of 10").
Key Components (Question Types): The engine will support a variety of question types to assess different skills:
MultipleChoiceQuestion: The classic format with radio buttons or checkboxes.
FillInTheBlankQuestion: A sentence with an input field for the missing word(s).
DragAndDropMatcher: Two columns of items (e.g., words and definitions) that the user must connect.
SpeechRecognitionQuestion: A prompt for the user to speak a given phrase, which is then analyzed for pronunciation accuracy.
OpenEndedQuestion: A text area for longer, written responses.
Feedback Mechanism: Immediate, clear feedback is a pedagogical imperative.19 After submitting an answer, the interface will instantly show a "Correct" or "Incorrect" state. For incorrect answers, a concise explanation of the correct answer will be provided to turn the assessment into a learning opportunity.19
QuizSummaryScreen: Upon completion, a results screen will display the final score, a list of questions answered incorrectly with explanations, and a summary of the XP and any badges earned.

4.5 The Centralized Resource Library

This section serves as a digital repository for all supplementary materials, providing a single point of access for students. The design should prioritize efficient search and filtering.41
Layout: A modern and visually appealing "Bento Box" grid layout. This layout uses different-sized grid cells to create a dynamic and engaging presentation that can accommodate various media types (e.g., a large cell for a featured video, smaller cells for PDFs).42
Key Components:
ResourceFilter: A set of controls allowing users to filter the library by Resource Type (PDF, Video, Audio, Web Link), associated Course, and Topic/Tag.
ResourceCard: Each item in the grid will be a card displaying a relevant icon or thumbnail, the resource title, its type, and a brief description.
ResourceViewerModal: To maintain context and prevent unnecessary navigation, clicking a resource card will open the content in a modal overlay (e.g., an embedded PDF viewer or video player) rather than navigating to a new page.

4.6 The Gamified User Profile & Progress Center

The profile page is where users can track their long-term progress, view their achievements, and manage their account. It is a key driver of motivation and a reflection of the user's investment in the platform.43
Layout: The page will be organized into clear, logical tabs or expandable sections to prevent information overload. The primary sections will be "Profile," "Statistics," and "Achievements".43
Key Components:
ProfileHeader: Located at the top of the page, this component will display the user's avatar, name, username, and join date. An "Edit Profile" button will allow them to update this information.
StatsPanel: A dedicated tab featuring a visual dashboard of the user's learning journey. It will use charts and graphs to display key metrics like "XP Gained Over Time," "Skill Breakdown" (e.g., a radar chart showing proficiency in grammar, vocabulary, speaking), and "Activity Calendar" (e.g., a heatmap showing learning days).43
AchievementsGrid: A visually engaging grid displaying all available badges. Earned badges will be shown in full color, while unearned badges will be greyed out with a description of how to unlock them, creating a clear incentive for continued engagement.
CoursesInProgress: A list of all courses the user is currently enrolled in, each with its own progress bar, providing a quick summary of their active learning.
Settings: A separate, clearly marked section for managing account details such as email address, password, notification preferences, and subscription information.
Component Name
Props
Description
CourseCard
title: string, description: string, imageUrl: string, level: 'Beginner' | 'Intermediate' | 'Advanced', progress: number
Displays a course preview in the catalog. The entire card is a clickable link to the course details page. Shows a progress bar if progress > 0.
LessonStep
stepNumber: number, title: string, type: 'Video' | 'Quiz' | 'Reading', status: 'completed' | 'active' | 'locked'
An item in the LessonStepper sidebar. Visually indicates its status and allows navigation to that step in the lesson.
ProgressBar
value: number, size: 'sm' | 'md'
A visual bar indicating progress from 0 to 100. Used in various components like CourseCard and DailyGoalsCard.
Badge
label: string, colorScheme: 'info' | 'success' | 'warning'
A small, colored tag used to display information like course difficulty or resource type.
AchievementIcon
name: string, description: string, unlocked: boolean
Displays a single achievement badge in the AchievementsGrid. Appears in full color if unlocked is true, otherwise greyed out. A tooltip shows the description.
StatCard
value: string | number, label: string, icon: ReactNode
A small card used in the StatsOverviewCard on the dashboard to display a single key metric (e.g., "7-Day Streak").


Section 5: The Master Prompt for GitHub Copilot

This final section synthesizes all preceding design and architectural decisions into a structured, comprehensive master prompt for GitHub Copilot. This prompt is designed to be executed sequentially, guiding the AI to build the application's front end with precision and care, from the foundational design system to the final page assembly.

5.1 Prompting Strategy: The "System-to-Component" Hierarchy

To ensure a robust and maintainable codebase, the prompting strategy will mirror a professional front-end development workflow. Instead of a single, monolithic prompt, the instructions are broken down into a logical hierarchy. This approach allows for iterative development and easier debugging.
Part 1: Project Setup & Technology Stack. This initial prompt establishes the project environment. It specifies the use of a modern toolchain (React with Vite for speed), a utility-first CSS framework (Tailwind CSS for rapid and consistent styling), and a component library for accessibility (Headless UI or Shadcn/ui).
Part 2: Design System Implementation. This prompt instructs Copilot to translate the Design System Specifications (from Section 2) into code. It will involve configuring the tailwind.config.js file with the exact color palette, font families, and spacing scale defined in the design system. This is the most critical step for ensuring visual consistency.
Part 3: Atomic Component Creation. This series of prompts focuses on building the smallest, reusable UI elements (e.g., Button, Input, Card, Badge). Each prompt will be highly specific, defining the component's props (its API), visual states (hover, focus, disabled), and adherence to the design system.
Part 4: Page View Assembly. Once the atomic components are built, these prompts will instruct Copilot to compose them into the full page layouts defined in Section 4 (e.g., Dashboard, Learn Page, Profile Page). This involves arranging the components in the specified layout and passing placeholder data.
Part 5: Application Routing. The final prompt will set up the client-side routing (using a library like React Router) to link all the created pages together, making the application navigable.

5.2 Sample Prompt Structure (for a single component)

Each prompt for creating a component will be meticulously structured to leave no room for ambiguity. This ensures the AI generates code that is not only functional but also aligns perfectly with the architectural and design requirements.
// Role and Goal: Sets the context for the AI. Example: "You are an expert front-end developer specializing in creating accessible, reusable components in React with TypeScript and Tailwind CSS. Your goal is to build the CourseCard component."
// Design System Constraints: Enforces adherence to the established visual rules. Example: "You MUST strictly use the design tokens defined in tailwind.config.js. For colors, use classes like bg-primary-background or text-accent. For spacing, use classes like p-4 (for spacing.md) or gap-2 (for spacing.sm). DO NOT use arbitrary values like style={{color: '#FFF'}} or className="p-[15px]"."
// Component API (Props): Defines the component's interface using TypeScript types. Example: "The component must accept the following props, defined by this TypeScript interface: interface CourseCardProps { title: string; description: string; imageUrl: string; level: 'Beginner' | 'Intermediate' | 'Advanced'; progress?: number; // Optional, 0-100 }"
// Structural and Functional Requirements: Describes the component's layout and behavior. Example: "The component should be a div with a border and shadow. Inside, it must contain an img tag for imageUrl at the top. Below the image, display an h3 for the title, a Badge component for the level, and a p tag for the description. If the progress prop is provided and greater than 0, render a ProgressBar component at the very bottom."
// Interaction States: Specifies visual feedback for user actions. Example: "On hover, the card's shadow should increase (shadow-lg), and it should scale up slightly (transform scale-105). Add a smooth transition effect for these properties."
// Accessibility: Ensures the component is usable by everyone. Example: "The main container should be a clickable a tag or have an onClick handler with role='button' and tabIndex=0. The img tag must have an alt attribute, which should be the course title."
// Code Implementation: The final command. Example: "Now, write the complete code for the CourseCard.tsx component."

5.3 The Complete Prompt Document

The following is the complete, multi-part prompt designed to be provided to GitHub Copilot to generate the front end for the rozmoWA application.

Part 1: Project Setup




// Role and Goal: You are a senior full-stack developer initializing a new web application project. Your goal is to set up a modern, efficient, and scalable front-end environment using React, Vite, TypeScript, and Tailwind CSS.

// Task: Generate the necessary commands to create and configure the project.

// Steps:
// 1. Create a new React project named "rozmowa-app" using Vite with the TypeScript template.
// 2. Navigate into the new project directory.
// 3. Install Tailwind CSS and its peer dependencies (`postcss`, `autoprefixer`).
// 4. Generate the `tailwind.config.js` and `postcss.config.js` files.
// 5. Configure the `tailwind.config.js` file's `content` array to include all relevant source files (`.html`, `.tsx`).
// 6. Add the Tailwind directives (`@tailwind base; @tailwind components; @tailwind utilities;`) to the main CSS file (e.g., `src/index.css`).
// 7. Install `lucide-react` for iconography.
// 8. Install `react-router-dom` for client-side routing.
// 9. Clean up the default Vite template files in `src`, leaving a clean `App.tsx` and `main.tsx`.

// Now, provide the sequence of terminal commands to accomplish these steps.



Part 2: Design System Implementation




// Role and Goal: You are a front-end developer tasked with implementing a precise design system. Your goal is to configure Tailwind CSS to use custom design tokens for colors, fonts, and spacing, ensuring all future development adheres to the brand's visual identity.

// Task: Modify the `tailwind.config.js` file to reflect the rozmoWA design system.

// Design System Specifications:
/*
- Colors (Light Mode Values):
  - primary-background: hsl(30, 25%, 95%)
  - container-background: hsl(0, 0%, 100%)
  - primary-text: hsl(240, 10%, 15%)
  - secondary-text: hsl(240, 5%, 45%)
  - accent: hsl(350, 85%, 55%)
  - success: hsl(140, 70%, 40%)
  - info: hsl(210, 80%, 50%)
  - border: hsl(240, 10%, 85%)
- Colors (Dark Mode Values - to be used with `dark:` prefix):
  - primary-background: hsl(240, 10%, 12%)
  - container-background: hsl(240, 6%, 16%)
  - primary-text: hsl(30, 25%, 95%)
  - secondary-text: hsl(240, 5%, 65%)
  - accent: hsl(350, 90%, 65%)
  - success: hsl(140, 60%, 55%)
  - info: hsl(210, 85%, 65%)
  - border: hsl(240, 5%, 25%)
- Typography:
  - Heading Font Family ('heading'): Poppins, sans-serif
  - Body/UI Font Family ('sans'): Inter, sans-serif
- Spacing:
  - Base unit is 4px. Create a scale from 0 to 64 using multiples of the base unit.
*/

// Implementation Instructions:
// 1. In `tailwind.config.js`, enable dark mode using the `class` strategy.
// 2. Extend the `theme.colors` object with the specified color palette. Use meaningful names (e.g., `primary-background`, `accent`).
// 3. Extend the `theme.fontFamily` object to include the 'heading' and 'sans' font families.
// 4. Ensure the default sans-serif font is 'Inter'.
// 5. Create a `<body>` rule in `index.css` to apply the default background and text colors for both light and dark modes.

// Now, write the complete, updated `tailwind.config.js` file.



Part 3: Atomic Component Creation (Example for Button)




// Role and Goal: You are an expert React developer creating a reusable Button component. The goal is to build a flexible, accessible, and visually consistent button that will be used throughout the application.

// Task: Create a new file at `src/components/Button.tsx` and write the code for the Button component.

// Design System Constraints:
// - MUST use the design tokens from `tailwind.config.js`. Use classes like `bg-accent`, `text-primary-text`, `rounded-md`, `p-2`, etc.
// - DO NOT use arbitrary values.

// Component API (Props):
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

// Structural and Functional Requirements:
// - The component should render a standard HTML `<button>` element.
// - It should accept all standard button attributes (e.g., `onClick`, `disabled`, `type`).
// - The `variant` prop controls the styling:
//   - 'primary': Solid background color (`bg-accent`), white text.
//   - 'secondary': Bordered (`border-border`), transparent background, primary text color.
//   - 'ghost': No border or background, primary text color.
// - The `size` prop controls padding and font size.
// - If `leftIcon` or `rightIcon` are provided, render them inside the button next to the children, with appropriate spacing.

// Interaction States:
// - On hover, primary and secondary variants should become slightly brighter/darker. Ghost variant should get a subtle background color.
// - On focus, a visible outline ring should appear (e.g., `focus:ring-2 focus:ring-accent`).
// - When disabled, the button should have reduced opacity (`opacity-50`) and pointer events should be disabled (`cursor-not-allowed`).

// Accessibility:
// - The component must be fully keyboard navigable.
// - Ensure `aria-disabled` is set when the button is disabled.

// Now, write the complete code for the `Button.tsx` component.


(This process would be repeated for other atomic components: Card, Input, Badge, ProgressBar, etc.)

Part 4: Page View Assembly (Example for Dashboard)




// Role and Goal: You are a UI developer assembling a page view from existing components. Your goal is to create the main Dashboard page layout.

// Task: Create a new file at `src/pages/Dashboard.tsx` and write the code for the Dashboard page. Assume all necessary atomic and composite components (`ContinueLearningCard`, `DailyGoalsCard`, `ReviewQueueCard`, `StatsOverviewCard`, `StatCard`) have already been created.

// Structural and Functional Requirements:
// - The main container should be a `div` with appropriate padding.
// - The layout should be a responsive grid (e.g., using CSS Grid). On larger screens (md and up), it should be a two or three-column layout. On smaller screens, it should stack into a single column.
// - The `ContinueLearningCard` should be the most prominent item, spanning two columns if possible on larger screens.
// - The `DailyGoalsCard` and `ReviewQueueCard` should be placed near the top, in the first row.
// - The `StatsOverviewCard` should be a container that holds multiple `StatCard` components, displayed in a row.
// - Use placeholder data for all components for now. For example, for the `ContinueLearningCard`, pass props like `title="Present Perfect Tense"`, `course="Grammar Essentials"`, `progress={45}`.

// Now, write the complete code for the `Dashboard.tsx` page component.


(This process would be repeated for all other pages: LearnPage, ResourceLibrary, ProfilePage, etc.)

Part 5: Application Routing




// Role and Goal: You are a front-end developer setting up the navigation structure for the entire application.

// Task: Modify the `App.tsx` file to implement client-side routing using `react-router-dom`.

// Structural and Functional Requirements:
// 1. Import `BrowserRouter`, `Routes`, and `Route` from `react-router-dom`.
// 2. Import all the page components you have created: `Dashboard`, `LearnPage`, `ReviewPage`, `ResourceLibrary`, `ProfilePage`.
// 3. Create a persistent layout component (e.g., `MainLayout.tsx`) that includes a `Sidebar` (for desktop) and a `BottomNav` (for mobile). This layout component should render an `<Outlet />` for the page content.
// 4. In `App.tsx`, set up the routes within the `BrowserRouter`.
// 5. The root path `/` should render the `Dashboard` page inside the `MainLayout`.
// 6. Define routes for `/learn`, `/review`, `/resources`, and `/profile`, each rendering their respective page component within the `MainLayout`.

// Now, write the code for the `MainLayout.tsx` component and the final `App.tsx` file with the complete routing structure.



**Files to modify:**
- `path/to/file1.tsx`
- `path/to/file2.ts`

**Expected outcome:** What should happen when this is complete

---

### Task 2: [Add your next task title here]
**Description:** Describe the next task

**Details:**
- [ ] Step or requirement 1
- [ ] Step or requirement 2

**Files to modify:**
- `path/to/file.tsx`

**Expected outcome:** What should happen when this is complete

---

## ‚úÖ Completed Tasks

### Deep Repository Analysis & Understanding ‚ú®

**Status:** Complete ‚Äî Comprehensive exploration finished  
**Completion Date:** November 3, 2025  
**Documents Created:**
- `docs/SOUL_OF_ROZMOWA.md` ‚Äî Deep architectural and philosophical analysis
- `docs/ENHANCEMENT_ROADMAP.md` ‚Äî Phased implementation plan

**What Was Understood:**

1. **The Soul** üåô
   - rozmoWA is a **bridge between worlds**, teaching English to Polish speakers
   - Philosophy: "Structured Fun" ‚Äî rigorous curriculum + meaningful gamification
   - Emotional design with poetic lesson descriptions and encouraging feedback
   - Moon symbolism representing transformation and cycles

2. **The Architecture** üèóÔ∏è
   - React 19 + TypeScript + Vite (modern, fast)
   - 6,711 lines of code across src/
   - Simple state management (no Redux) - useState + localStorage
   - 7 exercise types: multiple_choice, type_answer, listen_and_select, listen_and_type, drag_words, image_match, fill_blanks
   - Data flow: localStorage ‚Üî App.tsx ‚Üî Components
   - Design system: Custom CSS with glass morphism, purple/teal/gold palette

3. **The Content** üìö
   - 3 Units (A0, A1, A2 CEFR levels)
   - ~20 lessons total
   - ~140-150 exercises
   - Themes: Greetings, Numbers, Colors, Family, Weather, Travel, etc.
   - Each lesson has poetic Polish/English descriptions

4. **The Design** üé®
   - Color philosophy: "Ivory Moonlight with Cosmic Accents"
   - Extensive glass morphism effects
   - Custom CSS (not Tailwind) - 1,627 lines in App.css
   - Framer Motion for smooth animations
   - Token-based spacing, shadows, typography

5. **Current State** üîç
   - **Strengths:** Clean architecture, type-safe, modern tooling, emotional design
   - **Opportunities:** 
     - `_archived` folder needs cleanup (2,000+ lines of unused code)
     - Achievement system defined but not dynamically unlocked
     - No review system (Anki-style spaced repetition)
     - Dark mode designed but not implemented
     - i18n installed but underutilized
     - CSS could be more modular

**Next Steps Identified:**

See `docs/ENHANCEMENT_ROADMAP.md` for detailed phased plan:
- Phase 1: Foundation refinement (code org, hooks extraction, achievement unlocking)
- Phase 2: UI/UX enhancements (dark mode, design system, component library)
- Phase 3: Learning experience (review system, better audio, exercise standardization)
- Phase 4: Internationalization & content management
- Phase 5: Advanced features & polish

---

## üìù Notes

- Keep task descriptions clear and specific
- Include file paths when known
- List any dependencies or prerequisites
- Add any reference links or examples that might help

---

**Instructions for use:**
1. Add your tasks in the "Task Queue" section above
2. Be as specific as possible about what you want
3. Mention me (@copilot) or tag this file in your message
4. I'll work through tasks in order and move them to "Completed Tasks" when done
